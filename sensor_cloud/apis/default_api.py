# coding: utf-8

"""
    Sensor Data API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 2.20
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def aggregation_get(self, streamid, **kwargs):
        """
        Calculate an aggregated view of observations.
        Calculate an aggregated view of observations. The aggregation is calculated on demand.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregation_get(streamid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: Stream identifier (required)
        :param str start: Start date (url encoded iso8601 format)
        :param str end: End date (url encoded iso8601 format)
        :param bool si: Is the start parameter treated as an inclusive boundary
        :param bool ei: Is the end parameter treated as an inclusive boundary
        :param float limit: Limit the number of results. The limit is 1000 by default.
        :param float aggperiod: The number of milliseconds in each aggregation interval.
        :param str count: Include this parameter to return a count of the observations in a stream. (Note, a value is not required for this parameter.)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.aggregation_get_with_http_info(streamid, **kwargs)
        else:
            (data) = self.aggregation_get_with_http_info(streamid, **kwargs)
            return data

    def aggregation_get_with_http_info(self, streamid, **kwargs):
        """
        Calculate an aggregated view of observations.
        Calculate an aggregated view of observations. The aggregation is calculated on demand.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregation_get_with_http_info(streamid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: Stream identifier (required)
        :param str start: Start date (url encoded iso8601 format)
        :param str end: End date (url encoded iso8601 format)
        :param bool si: Is the start parameter treated as an inclusive boundary
        :param bool ei: Is the end parameter treated as an inclusive boundary
        :param float limit: Limit the number of results. The limit is 1000 by default.
        :param float aggperiod: The number of milliseconds in each aggregation interval.
        :param str count: Include this parameter to return a count of the observations in a stream. (Note, a value is not required for this parameter.)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['streamid', 'start', 'end', 'si', 'ei', 'limit', 'aggperiod', 'count']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregation_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'streamid' is set
        if ('streamid' not in params) or (params['streamid'] is None):
            raise ValueError("Missing the required parameter `streamid` when calling `aggregation_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'streamid' in params:
            query_params.append(('streamid', params['streamid']))
        if 'start' in params:
            query_params.append(('start', params['start']))
        if 'end' in params:
            query_params.append(('end', params['end']))
        if 'si' in params:
            query_params.append(('si', params['si']))
        if 'ei' in params:
            query_params.append(('ei', params['ei']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'aggperiod' in params:
            query_params.append(('aggperiod', params['aggperiod']))
        if 'count' in params:
            query_params.append(('count', params['count']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/aggregation', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_collectionid_shares_get(self, collectionid, **kwargs):
        """
        Get shares for a collection
        Get shares for a collection
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_collectionid_shares_get(collectionid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str collectionid: (required)
        :param str id: Only return shares with this id or partial match using wildcards (*, ?).  \\n* matches zero or more characters.\\n* ? matches exactly one character.\\n\\nFor example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of shares to return
        :param float skip: Skip this many results
        :param bool expand: Return full details of matching shares
        :param bool recursive: Return full details of embedded resources
        :param str organisationid: Filter response by this organisation id
        :param str groupid: Filter response by a comma separated list of group ids
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_collectionid_shares_get_with_http_info(collectionid, **kwargs)
        else:
            (data) = self.collections_collectionid_shares_get_with_http_info(collectionid, **kwargs)
            return data

    def collections_collectionid_shares_get_with_http_info(self, collectionid, **kwargs):
        """
        Get shares for a collection
        Get shares for a collection
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_collectionid_shares_get_with_http_info(collectionid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str collectionid: (required)
        :param str id: Only return shares with this id or partial match using wildcards (*, ?).  \\n* matches zero or more characters.\\n* ? matches exactly one character.\\n\\nFor example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of shares to return
        :param float skip: Skip this many results
        :param bool expand: Return full details of matching shares
        :param bool recursive: Return full details of embedded resources
        :param str organisationid: Filter response by this organisation id
        :param str groupid: Filter response by a comma separated list of group ids
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collectionid', 'id', 'limit', 'skip', 'expand', 'recursive', 'organisationid', 'groupid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collectionid_shares_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collectionid' is set
        if ('collectionid' not in params) or (params['collectionid'] is None):
            raise ValueError("Missing the required parameter `collectionid` when calling `collections_collectionid_shares_get`")


        collection_formats = {}

        path_params = {}
        if 'collectionid' in params:
            path_params['collectionid'] = params['collectionid']

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'groupid' in params:
            query_params.append(('groupid', params['groupid']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/{collectionid}/shares', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_collectionid_shares_id_delete(self, collectionid, id, **kwargs):
        """
        Delete a share from an existing collection.
        Delete a share from an existing collection. The client must have an appropriate delete collection permission
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_collectionid_shares_id_delete(collectionid, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str collectionid: (required)
        :param str id: The unique identifier for the share to be deleted from the collection (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_collectionid_shares_id_delete_with_http_info(collectionid, id, **kwargs)
        else:
            (data) = self.collections_collectionid_shares_id_delete_with_http_info(collectionid, id, **kwargs)
            return data

    def collections_collectionid_shares_id_delete_with_http_info(self, collectionid, id, **kwargs):
        """
        Delete a share from an existing collection.
        Delete a share from an existing collection. The client must have an appropriate delete collection permission
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_collectionid_shares_id_delete_with_http_info(collectionid, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str collectionid: (required)
        :param str id: The unique identifier for the share to be deleted from the collection (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collectionid', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collectionid_shares_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collectionid' is set
        if ('collectionid' not in params) or (params['collectionid'] is None):
            raise ValueError("Missing the required parameter `collectionid` when calling `collections_collectionid_shares_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `collections_collectionid_shares_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'collectionid' in params:
            path_params['collectionid'] = params['collectionid']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/{collectionid}/shares/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_collectionid_shares_id_get(self, collectionid, id, **kwargs):
        """
        Get details about a share resource
        Get details about a specific share resource
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_collectionid_shares_id_get(collectionid, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str collectionid: (required)
        :param str id: The unique identifier for the share to be deleted from the collection (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_collectionid_shares_id_get_with_http_info(collectionid, id, **kwargs)
        else:
            (data) = self.collections_collectionid_shares_id_get_with_http_info(collectionid, id, **kwargs)
            return data

    def collections_collectionid_shares_id_get_with_http_info(self, collectionid, id, **kwargs):
        """
        Get details about a share resource
        Get details about a specific share resource
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_collectionid_shares_id_get_with_http_info(collectionid, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str collectionid: (required)
        :param str id: The unique identifier for the share to be deleted from the collection (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collectionid', 'id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collectionid_shares_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collectionid' is set
        if ('collectionid' not in params) or (params['collectionid'] is None):
            raise ValueError("Missing the required parameter `collectionid` when calling `collections_collectionid_shares_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `collections_collectionid_shares_id_get`")


        collection_formats = {}

        path_params = {}
        if 'collectionid' in params:
            path_params['collectionid'] = params['collectionid']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/{collectionid}/shares/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_count_get(self, **kwargs):
        """
        Get a count of collections.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_count_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of platforms
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str streamids: filter response by a comma separated list of stream ids
        :return: CollectionCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_count_get_with_http_info(**kwargs)
        else:
            (data) = self.collections_count_get_with_http_info(**kwargs)
            return data

    def collections_count_get_with_http_info(self, **kwargs):
        """
        Get a count of collections.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_count_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of platforms
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str streamids: filter response by a comma separated list of stream ids
        :return: CollectionCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'skip', 'organisationid', 'expand', 'recursive', 'groupids', 'streamids']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_count_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'streamids' in params:
            query_params.append(('streamids', params['streamids']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CollectionCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_get(self, **kwargs):
        """
        Get a list of collections.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of platforms
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str streamids: filter response by a comma separated list of stream ids
        :return: CollectionCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_get_with_http_info(**kwargs)
        else:
            (data) = self.collections_get_with_http_info(**kwargs)
            return data

    def collections_get_with_http_info(self, **kwargs):
        """
        Get a list of collections.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of platforms
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str streamids: filter response by a comma separated list of stream ids
        :return: CollectionCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'skip', 'organisationid', 'expand', 'recursive', 'groupids', 'streamids']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'streamids' in params:
            query_params.append(('streamids', params['streamids']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CollectionCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_id_delete(self, id, **kwargs):
        """
        Delete an existing Collection.
        Delete an existing Collection. The client must have an appropriate delete Collection permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.collections_id_delete_with_http_info(id, **kwargs)
            return data

    def collections_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing Collection.
        Delete an existing Collection. The client must have an appropriate delete Collection permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `collections_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_id_get(self, id, **kwargs):
        """
        Get details about a collection.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Collection id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.collections_id_get_with_http_info(id, **kwargs)
            return data

    def collections_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a collection.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Collection id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `collections_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_id_put(self, id, **kwargs):
        """
        Create or update a collection
        Create or update a collection
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_id_put(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The unique identifier for the target collection to create or update (required)
        :param CollectionPut body:
        :param bool recursive: Return full details of the created or updated collection
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_id_put_with_http_info(id, **kwargs)
        else:
            (data) = self.collections_id_put_with_http_info(id, **kwargs)
            return data

    def collections_id_put_with_http_info(self, id, **kwargs):
        """
        Create or update a collection
        Create or update a collection
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_id_put_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The unique identifier for the target collection to create or update (required)
        :param CollectionPut body:
        :param bool recursive: Return full details of the created or updated collection
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `collections_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def collections_post(self, body, **kwargs):
        """
        Create a new collection.
        Create a new collection. Do not provide the id property in the body. The server will generate a UUID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_post(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CollectionPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.collections_post_with_http_info(body, **kwargs)
        else:
            (data) = self.collections_post_with_http_info(body, **kwargs)
            return data

    def collections_post_with_http_info(self, body, **kwargs):
        """
        Create a new collection.
        Create a new collection. Do not provide the id property in the body. The server will generate a UUID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.collections_post_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CollectionPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `collections_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/collections', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def groups_get(self, **kwargs):
        """
        Get a collection of groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return groups with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str organisationid: filter response by this organisation id
        :param str groupids: filter response by a comma separated list of group ids
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param bool expand: Return full details of groups
        :param bool recursive: Return full details of groups and linked objects
        :return: GroupCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.groups_get_with_http_info(**kwargs)
        else:
            (data) = self.groups_get_with_http_info(**kwargs)
            return data

    def groups_get_with_http_info(self, **kwargs):
        """
        Get a collection of groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return groups with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str organisationid: filter response by this organisation id
        :param str groupids: filter response by a comma separated list of group ids
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param bool expand: Return full details of groups
        :param bool recursive: Return full details of groups and linked objects
        :return: GroupCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'organisationid', 'groupids', 'limit', 'skip', 'expand', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method groups_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/groups', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GroupCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def groups_id_delete(self, id, **kwargs):
        """
        Delete an existing group.
        Delete an existing Group. The client must have an appropriate delete Group permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove group even when not empty.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.groups_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.groups_id_delete_with_http_info(id, **kwargs)
            return data

    def groups_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing group.
        Delete an existing Group. The client must have an appropriate delete Group permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove group even when not empty.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method groups_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `groups_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/groups/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def groups_id_get(self, id, **kwargs):
        """
        Get details about a group.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Group id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.groups_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.groups_id_get_with_http_info(id, **kwargs)
            return data

    def groups_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a group.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Group id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method groups_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `groups_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/groups/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def groups_id_put(self, id, body, **kwargs):
        """
        Create a new or update an existing group.
        Create a new group. If a group with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_id_put(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param GroupPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.groups_id_put_with_http_info(id, body, **kwargs)
        else:
            (data) = self.groups_id_put_with_http_info(id, body, **kwargs)
            return data

    def groups_id_put_with_http_info(self, id, body, **kwargs):
        """
        Create a new or update an existing group.
        Create a new group. If a group with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.groups_id_put_with_http_info(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param GroupPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method groups_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `groups_id_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `groups_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/groups/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def invitations_id_accept_post(self, id, **kwargs):
        """
        Accepts an invitation
        Accepts an invitation.  Only the invited user can accept invitations.  Invitations can only be accepted once.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invitations_id_accept_post(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The unique identifier for the target invitation (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.invitations_id_accept_post_with_http_info(id, **kwargs)
        else:
            (data) = self.invitations_id_accept_post_with_http_info(id, **kwargs)
            return data

    def invitations_id_accept_post_with_http_info(self, id, **kwargs):
        """
        Accepts an invitation
        Accepts an invitation.  Only the invited user can accept invitations.  Invitations can only be accepted once.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invitations_id_accept_post_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The unique identifier for the target invitation (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invitations_id_accept_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `invitations_id_accept_post`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/invitations/{id}/accept', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def invitations_id_get(self, id, **kwargs):
        """
        Get details about an invitation
        Get details about an invitation. Only users who sent the invitation are permitted to read the invitation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invitations_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The unique identifier for the target invitation (required)
        :param bool recursive: Return full details of embedded resources
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.invitations_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.invitations_id_get_with_http_info(id, **kwargs)
            return data

    def invitations_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about an invitation
        Get details about an invitation. Only users who sent the invitation are permitted to read the invitation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invitations_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The unique identifier for the target invitation (required)
        :param bool recursive: Return full details of embedded resources
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invitations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `invitations_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/invitations/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def invitations_post(self, **kwargs):
        """
        Send a new invitation
        Send a new invitation.  Users must have the AssignRolePermission to be able to send invitations within their organisation and/or group.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invitations_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param InvitationPost body: Information about the invitation to be sent.
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.invitations_post_with_http_info(**kwargs)
        else:
            (data) = self.invitations_post_with_http_info(**kwargs)
            return data

    def invitations_post_with_http_info(self, **kwargs):
        """
        Send a new invitation
        Send a new invitation.  Users must have the AssignRolePermission to be able to send invitations within their organisation and/or group.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invitations_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param InvitationPost body: Information about the invitation to be sent.
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invitations_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/hal+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/invitations', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def locations_count_get(self, **kwargs):
        """
        Get a count of locations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_count_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return locations with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str description: Only return locations with this description or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Limit the number of results. The limit is 1000 by default
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupids: filter response by this group id
        :param bool expand: Return full details of platforms
        :param str near: Return locations ordered based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to locations within this distance (in metres) of the 'near' location.
        :return: LocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.locations_count_get_with_http_info(**kwargs)
        else:
            (data) = self.locations_count_get_with_http_info(**kwargs)
            return data

    def locations_count_get_with_http_info(self, **kwargs):
        """
        Get a count of locations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_count_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return locations with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str description: Only return locations with this description or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Limit the number of results. The limit is 1000 by default
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupids: filter response by this group id
        :param bool expand: Return full details of platforms
        :param str near: Return locations ordered based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to locations within this distance (in metres) of the 'near' location.
        :return: LocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'description', 'limit', 'skip', 'organisationid', 'groupids', 'expand', 'near', 'radius']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_count_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'description' in params:
            query_params.append(('description', params['description']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'near' in params:
            query_params.append(('near', params['near']))
        if 'radius' in params:
            query_params.append(('radius', params['radius']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/locations/count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LocationCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def locations_get(self, **kwargs):
        """
        Get a collection of locations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return locations with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str description: Only return locations with this description or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Limit the number of results. The limit is 1000 by default
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupids: filter response by this group id
        :param bool expand: Return full details of platforms
        :param str near: Return locations ordered based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to locations within this distance (in metres) of the 'near' location.
        :return: LocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.locations_get_with_http_info(**kwargs)
        else:
            (data) = self.locations_get_with_http_info(**kwargs)
            return data

    def locations_get_with_http_info(self, **kwargs):
        """
        Get a collection of locations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return locations with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str description: Only return locations with this description or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Limit the number of results. The limit is 1000 by default
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupids: filter response by this group id
        :param bool expand: Return full details of platforms
        :param str near: Return locations ordered based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to locations within this distance (in metres) of the 'near' location.
        :return: LocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'description', 'limit', 'skip', 'organisationid', 'groupids', 'expand', 'near', 'radius']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'description' in params:
            query_params.append(('description', params['description']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'near' in params:
            query_params.append(('near', params['near']))
        if 'radius' in params:
            query_params.append(('radius', params['radius']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/locations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LocationCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def locations_id_delete(self, id, **kwargs):
        """
        Delete an existing location.
        Delete an existing Location. The client must have an appropriate delete Location permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove Location even when is referenced by other objects (eg. Platform deployments or Streams).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.locations_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.locations_id_delete_with_http_info(id, **kwargs)
            return data

    def locations_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing location.
        Delete an existing Location. The client must have an appropriate delete Location permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove Location even when is referenced by other objects (eg. Platform deployments or Streams).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `locations_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/locations/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def locations_id_get(self, id, **kwargs):
        """
        Get details about a location.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Location id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.locations_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.locations_id_get_with_http_info(id, **kwargs)
            return data

    def locations_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a location.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Location id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `locations_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/locations/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def locations_id_put(self, id, body, **kwargs):
        """
        Create a new or update an existing Location
        Create a new Location. If a Location with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_id_put(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param LocationPost body: A `Location` describes a point with a known latitude and longitude (and, optionally, elevation above mean sea level).  The coordinates of the `Location` are specified using a [GeoJSON Point](http://geojson.org/geojson-spec.html#point) object, which by convention lists coordinates in the order longitude, latitude then elevation.  For example, the following snippet defines a `Location` located at 42.903 degrees South, 147.327 degrees East, and 25 metres above mean sea level:      {       \"id\": \"NewLocation\",       \"organisationid\": \"MyOrg\",       \"geoJson\": {         \"type\": \"Point\",         \"coordinates\": [147.327, -42.903, 25.0]       }     }  If elevation is unknown, pass only two values (the longitude and latitude) in the `coordinates` property. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.locations_id_put_with_http_info(id, body, **kwargs)
        else:
            (data) = self.locations_id_put_with_http_info(id, body, **kwargs)
            return data

    def locations_id_put_with_http_info(self, id, body, **kwargs):
        """
        Create a new or update an existing Location
        Create a new Location. If a Location with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.locations_id_put_with_http_info(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param LocationPost body: A `Location` describes a point with a known latitude and longitude (and, optionally, elevation above mean sea level).  The coordinates of the `Location` are specified using a [GeoJSON Point](http://geojson.org/geojson-spec.html#point) object, which by convention lists coordinates in the order longitude, latitude then elevation.  For example, the following snippet defines a `Location` located at 42.903 degrees South, 147.327 degrees East, and 25 metres above mean sea level:      {       \"id\": \"NewLocation\",       \"organisationid\": \"MyOrg\",       \"geoJson\": {         \"type\": \"Point\",         \"coordinates\": [147.327, -42.903, 25.0]       }     }  If elevation is unknown, pass only two values (the longitude and latitude) in the `coordinates` property. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method locations_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `locations_id_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `locations_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/locations/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def observations_delete(self, streamid, **kwargs):
        """
        Delete observations from a stream
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.observations_delete(streamid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.observations_delete_with_http_info(streamid, **kwargs)
        else:
            (data) = self.observations_delete_with_http_info(streamid, **kwargs)
            return data

    def observations_delete_with_http_info(self, streamid, **kwargs):
        """
        Delete observations from a stream
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.observations_delete_with_http_info(streamid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['streamid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method observations_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'streamid' is set
        if ('streamid' not in params) or (params['streamid'] is None):
            raise ValueError("Missing the required parameter `streamid` when calling `observations_delete`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'streamid' in params:
            query_params.append(('streamid', params['streamid']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/observations', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def observations_get(self, streamid, **kwargs):
        """
        Get a collection of observations.
        Get a collection of observations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.observations_get(streamid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: Stream identifier or a comma separated list of stream identifiers (required)
        :param str start: Start date (url encoded iso8601 format)
        :param str end: End date (url encoded iso8601 format)
        :param str time: Timestamp of a specific result. (url encoded iso8601 format)
        :param bool si: Is the start parameter treated as an inclusive boundary
        :param bool ei: Is the end parameter treated as an inclusive boundary
        :param str bounds: Boundary filter for a geolocation stream, or any stream located by a geolocation stream. The boundary is provided as a POLYGON in WTK format.
        :param str media: Format of response. Valid formats are csv, json, geojson (for geolocationvalue streams)
        :param float limit: Limit the number of results. The limit is 1000 by default.
        :param str sort: Sort the results. By default results are returned in ascending order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.observations_get_with_http_info(streamid, **kwargs)
        else:
            (data) = self.observations_get_with_http_info(streamid, **kwargs)
            return data

    def observations_get_with_http_info(self, streamid, **kwargs):
        """
        Get a collection of observations.
        Get a collection of observations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.observations_get_with_http_info(streamid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: Stream identifier or a comma separated list of stream identifiers (required)
        :param str start: Start date (url encoded iso8601 format)
        :param str end: End date (url encoded iso8601 format)
        :param str time: Timestamp of a specific result. (url encoded iso8601 format)
        :param bool si: Is the start parameter treated as an inclusive boundary
        :param bool ei: Is the end parameter treated as an inclusive boundary
        :param str bounds: Boundary filter for a geolocation stream, or any stream located by a geolocation stream. The boundary is provided as a POLYGON in WTK format.
        :param str media: Format of response. Valid formats are csv, json, geojson (for geolocationvalue streams)
        :param float limit: Limit the number of results. The limit is 1000 by default.
        :param str sort: Sort the results. By default results are returned in ascending order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['streamid', 'start', 'end', 'time', 'si', 'ei', 'bounds', 'media', 'limit', 'sort']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method observations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'streamid' is set
        if ('streamid' not in params) or (params['streamid'] is None):
            raise ValueError("Missing the required parameter `streamid` when calling `observations_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'streamid' in params:
            query_params.append(('streamid', params['streamid']))
        if 'start' in params:
            query_params.append(('start', params['start']))
        if 'end' in params:
            query_params.append(('end', params['end']))
        if 'time' in params:
            query_params.append(('time', params['time']))
        if 'si' in params:
            query_params.append(('si', params['si']))
        if 'ei' in params:
            query_params.append(('ei', params['ei']))
        if 'bounds' in params:
            query_params.append(('bounds', params['bounds']))
        if 'media' in params:
            query_params.append(('media', params['media']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'sort' in params:
            query_params.append(('sort', params['sort']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/observations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def observations_post(self, streamid, body, **kwargs):
        """
        Upload observations for a stream
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.observations_post(streamid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: (required)
        :param ObservationsPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.observations_post_with_http_info(streamid, body, **kwargs)
        else:
            (data) = self.observations_post_with_http_info(streamid, body, **kwargs)
            return data

    def observations_post_with_http_info(self, streamid, body, **kwargs):
        """
        Upload observations for a stream
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.observations_post_with_http_info(streamid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str streamid: (required)
        :param ObservationsPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['streamid', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method observations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'streamid' is set
        if ('streamid' not in params) or (params['streamid'] is None):
            raise ValueError("Missing the required parameter `streamid` when calling `observations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `observations_post`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'streamid' in params:
            query_params.append(('streamid', params['streamid']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/observations', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def organisations_get(self, **kwargs):
        """
        Get a collection of organisations.
        This operations returns a list of all organisations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.organisations_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: OrganisationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.organisations_get_with_http_info(**kwargs)
        else:
            (data) = self.organisations_get_with_http_info(**kwargs)
            return data

    def organisations_get_with_http_info(self, **kwargs):
        """
        Get a collection of organisations.
        This operations returns a list of all organisations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.organisations_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: OrganisationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/organisations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='OrganisationCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def organisations_organisationid_get(self, organisationid, **kwargs):
        """
        Get details about an organisation.
        Get details about a specific organisation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.organisations_organisationid_get(organisationid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organisationid: Specify the orgnisation identifier (required)
        :return: Organisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.organisations_organisationid_get_with_http_info(organisationid, **kwargs)
        else:
            (data) = self.organisations_organisationid_get_with_http_info(organisationid, **kwargs)
            return data

    def organisations_organisationid_get_with_http_info(self, organisationid, **kwargs):
        """
        Get details about an organisation.
        Get details about a specific organisation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.organisations_organisationid_get_with_http_info(organisationid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organisationid: Specify the orgnisation identifier (required)
        :return: Organisation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organisationid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_organisationid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organisationid' is set
        if ('organisationid' not in params) or (params['organisationid'] is None):
            raise ValueError("Missing the required parameter `organisationid` when calling `organisations_organisationid_get`")


        collection_formats = {}

        path_params = {}
        if 'organisationid' in params:
            path_params['organisationid'] = params['organisationid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/organisations/{organisationid}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Organisation',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def organisations_organisationid_put(self, organisationid, body, **kwargs):
        """
        Update or create a new organisation.
        Add a new organisation. Only an administrator can create a new organisation. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.organisations_organisationid_put(organisationid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organisationid: (required)
        :param OrganisationPost body: This must match the organisationid parameter in the path (required)
        :return: Organisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.organisations_organisationid_put_with_http_info(organisationid, body, **kwargs)
        else:
            (data) = self.organisations_organisationid_put_with_http_info(organisationid, body, **kwargs)
            return data

    def organisations_organisationid_put_with_http_info(self, organisationid, body, **kwargs):
        """
        Update or create a new organisation.
        Add a new organisation. Only an administrator can create a new organisation. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.organisations_organisationid_put_with_http_info(organisationid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organisationid: (required)
        :param OrganisationPost body: This must match the organisationid parameter in the path (required)
        :return: Organisation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organisationid', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organisations_organisationid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organisationid' is set
        if ('organisationid' not in params) or (params['organisationid'] is None):
            raise ValueError("Missing the required parameter `organisationid` when calling `organisations_organisationid_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `organisations_organisationid_put`")


        collection_formats = {}

        path_params = {}
        if 'organisationid' in params:
            path_params['organisationid'] = params['organisationid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/organisations/{organisationid}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Organisation',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def platforms_get(self, **kwargs):
        """
        Get a collection of platforms.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return platforms with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str name: Only return platforms with this name or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of platforms
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str streamids: filter response by a comma separated list of stream ids
        :param str deployments_locationid: filter response to include only platforms deployed at this location. Note this will consider all deployment properties both past and present.
        :return: PlatformCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.platforms_get_with_http_info(**kwargs)
        else:
            (data) = self.platforms_get_with_http_info(**kwargs)
            return data

    def platforms_get_with_http_info(self, **kwargs):
        """
        Get a collection of platforms.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return platforms with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param str name: Only return platforms with this name or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of platforms
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str streamids: filter response by a comma separated list of stream ids
        :param str deployments_locationid: filter response to include only platforms deployed at this location. Note this will consider all deployment properties both past and present.
        :return: PlatformCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'limit', 'skip', 'organisationid', 'expand', 'recursive', 'groupids', 'streamids', 'deployments_locationid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method platforms_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'streamids' in params:
            query_params.append(('streamids', params['streamids']))
        if 'deployments_locationid' in params:
            query_params.append(('deployments.locationid', params['deployments_locationid']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/platforms', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PlatformCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def platforms_id_delete(self, id, **kwargs):
        """
        Delete an existing platform.
        Delete an existing Platform. The client must have an appropriate delete Platform permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove Platform even when is referenced by other objects (eg. SensorDeployments).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.platforms_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.platforms_id_delete_with_http_info(id, **kwargs)
            return data

    def platforms_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing platform.
        Delete an existing Platform. The client must have an appropriate delete Platform permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove Platform even when is referenced by other objects (eg. SensorDeployments).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method platforms_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `platforms_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/platforms/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def platforms_id_get(self, id, **kwargs):
        """
        Get details about a platform.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Platform id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.platforms_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.platforms_id_get_with_http_info(id, **kwargs)
            return data

    def platforms_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a platform.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Platform id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method platforms_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `platforms_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/platforms/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def platforms_id_put(self, id, body, **kwargs):
        """
        Create a new or update an existing platform.
        Create a new platform. If a platform with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_id_put(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param PlatformPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.platforms_id_put_with_http_info(id, body, **kwargs)
        else:
            (data) = self.platforms_id_put_with_http_info(id, body, **kwargs)
            return data

    def platforms_id_put_with_http_info(self, id, body, **kwargs):
        """
        Create a new or update an existing platform.
        Create a new platform. If a platform with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platforms_id_put_with_http_info(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param PlatformPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method platforms_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `platforms_id_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `platforms_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/platforms/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def procedures_get(self, **kwargs):
        """
        Get a collection of sensing procedures.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of sensing procedures to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of sensing procedures
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str observed_property: filter response by observedProperty
        :return: SensingProcedureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.procedures_get_with_http_info(**kwargs)
        else:
            (data) = self.procedures_get_with_http_info(**kwargs)
            return data

    def procedures_get_with_http_info(self, **kwargs):
        """
        Get a collection of sensing procedures.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of sensing procedures to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param bool expand: Return full details of sensing procedures
        :param bool recursive: Return full details of embedded resources
        :param str groupids: filter response by a comma separated list of group ids
        :param str observed_property: filter response by observedProperty
        :return: SensingProcedureCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'skip', 'organisationid', 'expand', 'recursive', 'groupids', 'observed_property']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procedures_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'observed_property' in params:
            query_params.append(('observedProperty', params['observed_property']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/procedures', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SensingProcedureCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def procedures_id_delete(self, id, **kwargs):
        """
        Delete an existing sensing procedure.
        Delete an existing sensing procedure. The client must have an appropriate delete sensing procedure permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove sensing procedure even when is referenced by other objects (eg. Streams).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.procedures_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.procedures_id_delete_with_http_info(id, **kwargs)
            return data

    def procedures_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing sensing procedure.
        Delete an existing sensing procedure. The client must have an appropriate delete sensing procedure permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool cascade: Remove sensing procedure even when is referenced by other objects (eg. Streams).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procedures_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `procedures_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/procedures/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def procedures_id_get(self, id, **kwargs):
        """
        Get details about a sensing procedures.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: sensing procedure id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.procedures_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.procedures_id_get_with_http_info(id, **kwargs)
            return data

    def procedures_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a sensing procedures.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: sensing procedure id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procedures_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `procedures_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/procedures/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def procedures_id_put(self, id, body, **kwargs):
        """
        Create a new or update an existing sensing procedure.
        Create a new sensing procedure. If a sensing procedure with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_id_put(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param SensingProcedurePost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.procedures_id_put_with_http_info(id, body, **kwargs)
        else:
            (data) = self.procedures_id_put_with_http_info(id, body, **kwargs)
            return data

    def procedures_id_put_with_http_info(self, id, body, **kwargs):
        """
        Create a new or update an existing sensing procedure.
        Create a new sensing procedure. If a sensing procedure with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.procedures_id_put_with_http_info(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param SensingProcedurePost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procedures_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `procedures_id_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `procedures_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/procedures/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def roles_get(self, **kwargs):
        """
        Get a collection of roles.
        This operation returns a list of all roles or all roles in the authorised organisation. An admin role with read role permission is required, or an organisational role with role read permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool expand: Return full details of roles
        :param bool recursive: Return full details of related objects
        :return: RoleCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.roles_get_with_http_info(**kwargs)
        else:
            (data) = self.roles_get_with_http_info(**kwargs)
            return data

    def roles_get_with_http_info(self, **kwargs):
        """
        Get a collection of roles.
        This operation returns a list of all roles or all roles in the authorised organisation. An admin role with read role permission is required, or an organisational role with role read permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool expand: Return full details of roles
        :param bool recursive: Return full details of related objects
        :return: RoleCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['expand', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method roles_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/roles', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RoleCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def roles_roleid_delete(self, roleid, **kwargs):
        """
        Delete an existing role.
        Delete an existing role. The client must have a delete role permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_roleid_delete(roleid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str roleid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.roles_roleid_delete_with_http_info(roleid, **kwargs)
        else:
            (data) = self.roles_roleid_delete_with_http_info(roleid, **kwargs)
            return data

    def roles_roleid_delete_with_http_info(self, roleid, **kwargs):
        """
        Delete an existing role.
        Delete an existing role. The client must have a delete role permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_roleid_delete_with_http_info(roleid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str roleid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roleid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method roles_roleid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'roleid' is set
        if ('roleid' not in params) or (params['roleid'] is None):
            raise ValueError("Missing the required parameter `roleid` when calling `roles_roleid_delete`")


        collection_formats = {}

        path_params = {}
        if 'roleid' in params:
            path_params['roleid'] = params['roleid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/roles/{roleid}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def roles_roleid_get(self, roleid, **kwargs):
        """
        Get details about a specific role.
        Get role details
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_roleid_get(roleid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str roleid: Specify the role identifier (required)
        :param bool recursive: Return full details of related objects
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.roles_roleid_get_with_http_info(roleid, **kwargs)
        else:
            (data) = self.roles_roleid_get_with_http_info(roleid, **kwargs)
            return data

    def roles_roleid_get_with_http_info(self, roleid, **kwargs):
        """
        Get details about a specific role.
        Get role details
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_roleid_get_with_http_info(roleid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str roleid: Specify the role identifier (required)
        :param bool recursive: Return full details of related objects
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roleid', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method roles_roleid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'roleid' is set
        if ('roleid' not in params) or (params['roleid'] is None):
            raise ValueError("Missing the required parameter `roleid` when calling `roles_roleid_get`")


        collection_formats = {}

        path_params = {}
        if 'roleid' in params:
            path_params['roleid'] = params['roleid']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/roles/{roleid}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Role',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def roles_roleid_put(self, roleid, body, **kwargs):
        """
        Update or create a role.
        Add or update a Role. The User will need to have admin level Roles for creating or updating a Role, or an organisation level Role for creating or updating a Role.  Permissions can be one or more of the following - .AllPermission, .AllReadPermission, .AssignRolePermission, .CreateCollectionPermission, .CreateGroupPermission, .CreateLocationPermission, .CreateOrganisationPermission, .CreatePlatformPermission, .CreateProcedurePermission, .CreateResultsPermission, .CreateRolePermission, .CreateSharePermission, .CreateStreamPermission, .CreateUserPermission, .DeleteCollectionPermission, .DeleteGroupPermission, .DeleteLocationPermission, .DeleteOrganisationPermission, .DeletePlatformPermission, .DeleteProcedurePermission, .DeleteResultsPermission, .DeleteRolePermission, .DeleteSharePermission, .DeleteStreamPermission, .DeleteUserPermission, .ReadCollectionPermission, .ReadGroupPermission, .ReadLocationPermission, .ReadModelPermission, .ReadOrganisationPermission, .ReadPlatformPermission, .ReadProcedurePermission, .ReadResultsPermission, .ReadRolePermission, .ReadSharePermission, .ReadStreamPermission, .ReadUserPermission, .ReadWorkflowPermission, .ReadWorkflowResultsPermission, .RunWorkflowPermission, .UpdateCollectionPermission, .UpdateGroupPermission, .UpdateLocationPermission, .UpdateOrganisationPermission, .UpdatePlatformPermission, .UpdateProcedurePermission, .UpdateResultsPermission, .UpdateRolePermission, .UpdateSharePermission, .UpdateStreamPermission, .UpdateUserPermission, .WriteModelPermission, .WriteWorkflowPermission.  A client can only assign a permission to a role of a certain role scope if they already have a role with the 'createrolepermission'. For example if user a has an OrganisationRole with 'createrolepermission' they will beable to create an organisation role with any permission. Importantly they can only create an organisation role for the organisation with which they already have a 'createrolepermission'.   Similarly, if a client has a GroupRole with createrolepermission on 'group1' then they can create an other GroupRole with any permission.  Given this, the 'createrolepermission' essentially allows the client to do anything with the the scope of the role. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_roleid_put(roleid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str roleid: (required)
        :param RolePost body: This must match the roleid parameter in the path (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.roles_roleid_put_with_http_info(roleid, body, **kwargs)
        else:
            (data) = self.roles_roleid_put_with_http_info(roleid, body, **kwargs)
            return data

    def roles_roleid_put_with_http_info(self, roleid, body, **kwargs):
        """
        Update or create a role.
        Add or update a Role. The User will need to have admin level Roles for creating or updating a Role, or an organisation level Role for creating or updating a Role.  Permissions can be one or more of the following - .AllPermission, .AllReadPermission, .AssignRolePermission, .CreateCollectionPermission, .CreateGroupPermission, .CreateLocationPermission, .CreateOrganisationPermission, .CreatePlatformPermission, .CreateProcedurePermission, .CreateResultsPermission, .CreateRolePermission, .CreateSharePermission, .CreateStreamPermission, .CreateUserPermission, .DeleteCollectionPermission, .DeleteGroupPermission, .DeleteLocationPermission, .DeleteOrganisationPermission, .DeletePlatformPermission, .DeleteProcedurePermission, .DeleteResultsPermission, .DeleteRolePermission, .DeleteSharePermission, .DeleteStreamPermission, .DeleteUserPermission, .ReadCollectionPermission, .ReadGroupPermission, .ReadLocationPermission, .ReadModelPermission, .ReadOrganisationPermission, .ReadPlatformPermission, .ReadProcedurePermission, .ReadResultsPermission, .ReadRolePermission, .ReadSharePermission, .ReadStreamPermission, .ReadUserPermission, .ReadWorkflowPermission, .ReadWorkflowResultsPermission, .RunWorkflowPermission, .UpdateCollectionPermission, .UpdateGroupPermission, .UpdateLocationPermission, .UpdateOrganisationPermission, .UpdatePlatformPermission, .UpdateProcedurePermission, .UpdateResultsPermission, .UpdateRolePermission, .UpdateSharePermission, .UpdateStreamPermission, .UpdateUserPermission, .WriteModelPermission, .WriteWorkflowPermission.  A client can only assign a permission to a role of a certain role scope if they already have a role with the 'createrolepermission'. For example if user a has an OrganisationRole with 'createrolepermission' they will beable to create an organisation role with any permission. Importantly they can only create an organisation role for the organisation with which they already have a 'createrolepermission'.   Similarly, if a client has a GroupRole with createrolepermission on 'group1' then they can create an other GroupRole with any permission.  Given this, the 'createrolepermission' essentially allows the client to do anything with the the scope of the role. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.roles_roleid_put_with_http_info(roleid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str roleid: (required)
        :param RolePost body: This must match the roleid parameter in the path (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roleid', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method roles_roleid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'roleid' is set
        if ('roleid' not in params) or (params['roleid'] is None):
            raise ValueError("Missing the required parameter `roleid` when calling `roles_roleid_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `roles_roleid_put`")


        collection_formats = {}

        path_params = {}
        if 'roleid' in params:
            path_params['roleid'] = params['roleid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/roles/{roleid}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Role',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def root_get(self, **kwargs):
        """
        Sensor Data API Root
        The root resource of the sensor data API. Provides links to other resources and some general meta-data about the user and the API 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.root_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.root_get_with_http_info(**kwargs)
        else:
            (data) = self.root_get_with_http_info(**kwargs)
            return data

    def root_get_with_http_info(self, **kwargs):
        """
        Sensor Data API Root
        The root resource of the sensor data API. Provides links to other resources and some general meta-data about the user and the API 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.root_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method root_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shares_count_get(self, **kwargs):
        """
        Get a count of current shares.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_count_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of shares to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupid: filter response by a comma separated list of group ids
        :param str collectionid: filter response by a comma separated list of collection ids
        :param bool expand: Return full details of shares
        :param bool recursive: Return full details of embedded resources
        :return: ShareCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shares_count_get_with_http_info(**kwargs)
        else:
            (data) = self.shares_count_get_with_http_info(**kwargs)
            return data

    def shares_count_get_with_http_info(self, **kwargs):
        """
        Get a count of current shares.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_count_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of shares to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupid: filter response by a comma separated list of group ids
        :param str collectionid: filter response by a comma separated list of collection ids
        :param bool expand: Return full details of shares
        :param bool recursive: Return full details of embedded resources
        :return: ShareCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'skip', 'organisationid', 'groupid', 'collectionid', 'expand', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shares_count_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'groupid' in params:
            query_params.append(('groupid', params['groupid']))
        if 'collectionid' in params:
            query_params.append(('collectionid', params['collectionid']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/shares/count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ShareCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shares_get(self, **kwargs):
        """
        Get a list of current shares.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of shares to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupid: filter response by a comma separated list of group ids
        :param str collectionid: filter response by a comma separated list of collection ids
        :param bool expand: Return full details of shares
        :param bool recursive: Return full details of embedded resources
        :return: ShareCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shares_get_with_http_info(**kwargs)
        else:
            (data) = self.shares_get_with_http_info(**kwargs)
            return data

    def shares_get_with_http_info(self, **kwargs):
        """
        Get a list of current shares.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param float limit: Maximum number of shares to return
        :param float skip: Skip this many results.
        :param str organisationid: filter response by this organisation id
        :param str groupid: filter response by a comma separated list of group ids
        :param str collectionid: filter response by a comma separated list of collection ids
        :param bool expand: Return full details of shares
        :param bool recursive: Return full details of embedded resources
        :return: ShareCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'skip', 'organisationid', 'groupid', 'collectionid', 'expand', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shares_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'groupid' in params:
            query_params.append(('groupid', params['groupid']))
        if 'collectionid' in params:
            query_params.append(('collectionid', params['collectionid']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/shares', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ShareCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shares_id_delete(self, id, **kwargs):
        """
        Delete an existing Share.
        Delete an existing Share. The client must have an appropriate delete Share permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shares_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.shares_id_delete_with_http_info(id, **kwargs)
            return data

    def shares_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing Share.
        Delete an existing Share. The client must have an appropriate delete Share permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shares_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `shares_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/shares/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shares_id_get(self, id, **kwargs):
        """
        Get details about a share.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Share id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shares_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.shares_id_get_with_http_info(id, **kwargs)
            return data

    def shares_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a share.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Share id (required)
        :param bool recursive: Return full details of embedded resources
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shares_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `shares_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/shares/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shares_id_put(self, id, body, **kwargs):
        """
        Update an existing Share.
        Update an existing Share. The existing object will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_id_put(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param SharePut body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shares_id_put_with_http_info(id, body, **kwargs)
        else:
            (data) = self.shares_id_put_with_http_info(id, body, **kwargs)
            return data

    def shares_id_put_with_http_info(self, id, body, **kwargs):
        """
        Update an existing Share.
        Update an existing Share. The existing object will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_id_put_with_http_info(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param SharePut body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shares_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `shares_id_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `shares_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/shares/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shares_post(self, body, **kwargs):
        """
        Create a new share.
        Create a new share. Do not provide the id property in the body. The server will generate a UUID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_post(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param SharePost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shares_post_with_http_info(body, **kwargs)
        else:
            (data) = self.shares_post_with_http_info(body, **kwargs)
            return data

    def shares_post_with_http_info(self, body, **kwargs):
        """
        Create a new share.
        Create a new share. Do not provide the id property in the body. The server will generate a UUID.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shares_post_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param SharePost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shares_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `shares_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/shares', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def streams_count_get(self, **kwargs):
        """
        Count a collection of streams.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_count_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return streams with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str resulttype: Return only Streams which match this resulttype. Valid resulttypes are geolocationvalue, scalarvalue, imagevalue and vectorvalue
        :param bool expand: Return full details of streams
        :param bool recursive: Return full details of embedded resources
        :param str groupids: Only return streams in this group
        :param str organisationid: Only return streams in this organisation
        :param str locationid: Only return streams with this location
        :param str near: Return streams at locations based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to streams that have locations within this distance (in metres) of the 'near' location.
        :param str stream_metadata_observed_property: Only return streams with this observed property URI
        :param str stream_metadata_unit_of_measure: Only return streams with this unit of measure URI
        :param str properties: Provide a comma separated list of properties to include in the collection.
        :return: StreamCollectionCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.streams_count_get_with_http_info(**kwargs)
        else:
            (data) = self.streams_count_get_with_http_info(**kwargs)
            return data

    def streams_count_get_with_http_info(self, **kwargs):
        """
        Count a collection of streams.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_count_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return streams with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str resulttype: Return only Streams which match this resulttype. Valid resulttypes are geolocationvalue, scalarvalue, imagevalue and vectorvalue
        :param bool expand: Return full details of streams
        :param bool recursive: Return full details of embedded resources
        :param str groupids: Only return streams in this group
        :param str organisationid: Only return streams in this organisation
        :param str locationid: Only return streams with this location
        :param str near: Return streams at locations based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to streams that have locations within this distance (in metres) of the 'near' location.
        :param str stream_metadata_observed_property: Only return streams with this observed property URI
        :param str stream_metadata_unit_of_measure: Only return streams with this unit of measure URI
        :param str properties: Provide a comma separated list of properties to include in the collection.
        :return: StreamCollectionCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'limit', 'skip', 'resulttype', 'expand', 'recursive', 'groupids', 'organisationid', 'locationid', 'near', 'radius', 'stream_metadata_observed_property', 'stream_metadata_unit_of_measure', 'properties']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method streams_count_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'resulttype' in params:
            query_params.append(('resulttype', params['resulttype']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'locationid' in params:
            query_params.append(('locationid', params['locationid']))
        if 'near' in params:
            query_params.append(('near', params['near']))
        if 'radius' in params:
            query_params.append(('radius', params['radius']))
        if 'stream_metadata_observed_property' in params:
            query_params.append(('streamMetadata.observedProperty', params['stream_metadata_observed_property']))
        if 'stream_metadata_unit_of_measure' in params:
            query_params.append(('streamMetadata.unitOfMeasure', params['stream_metadata_unit_of_measure']))
        if 'properties' in params:
            query_params.append(('properties', params['properties']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/streams/count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StreamCollectionCount',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def streams_get(self, **kwargs):
        """
        Get a collection of streams.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return streams with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str resulttype: Return only Streams which match this resulttype. Valid resulttypes are geolocationvalue, scalarvalue, imagevalue and vectorvalue
        :param bool expand: Return full details of streams
        :param bool recursive: Return full details of embedded resources
        :param str groupids: Only return streams in this group
        :param str organisationid: Only return streams in this organisation
        :param str locationid: Only return streams with this location
        :param str near: Return streams at locations based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to streams that have locations within this distance (in metres) of the 'near' location.
        :param str stream_metadata_observed_property: Only return streams with this observed property URI
        :param str stream_metadata_unit_of_measure: Only return streams with this unit of measure URI
        :param str properties: Provide a comma separated list of properties to include in the collection.
        :return: StreamCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.streams_get_with_http_info(**kwargs)
        else:
            (data) = self.streams_get_with_http_info(**kwargs)
            return data

    def streams_get_with_http_info(self, **kwargs):
        """
        Get a collection of streams.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Only return streams with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on.
        :param float limit: Maximum number of streams to return
        :param float skip: Skip this many results.
        :param str resulttype: Return only Streams which match this resulttype. Valid resulttypes are geolocationvalue, scalarvalue, imagevalue and vectorvalue
        :param bool expand: Return full details of streams
        :param bool recursive: Return full details of embedded resources
        :param str groupids: Only return streams in this group
        :param str organisationid: Only return streams in this organisation
        :param str locationid: Only return streams with this location
        :param str near: Return streams at locations based on how close they are to this WKT 'POINT'. For example 'near=POINT (lon lat)' where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id=25355 for WTK Specification and examples.
        :param float radius: Limit results to streams that have locations within this distance (in metres) of the 'near' location.
        :param str stream_metadata_observed_property: Only return streams with this observed property URI
        :param str stream_metadata_unit_of_measure: Only return streams with this unit of measure URI
        :param str properties: Provide a comma separated list of properties to include in the collection.
        :return: StreamCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'limit', 'skip', 'resulttype', 'expand', 'recursive', 'groupids', 'organisationid', 'locationid', 'near', 'radius', 'stream_metadata_observed_property', 'stream_metadata_unit_of_measure', 'properties']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method streams_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'skip' in params:
            query_params.append(('skip', params['skip']))
        if 'resulttype' in params:
            query_params.append(('resulttype', params['resulttype']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'groupids' in params:
            query_params.append(('groupids', params['groupids']))
        if 'organisationid' in params:
            query_params.append(('organisationid', params['organisationid']))
        if 'locationid' in params:
            query_params.append(('locationid', params['locationid']))
        if 'near' in params:
            query_params.append(('near', params['near']))
        if 'radius' in params:
            query_params.append(('radius', params['radius']))
        if 'stream_metadata_observed_property' in params:
            query_params.append(('streamMetadata.observedProperty', params['stream_metadata_observed_property']))
        if 'stream_metadata_unit_of_measure' in params:
            query_params.append(('streamMetadata.unitOfMeasure', params['stream_metadata_unit_of_measure']))
        if 'properties' in params:
            query_params.append(('properties', params['properties']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/streams', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StreamCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def streams_id_delete(self, id, **kwargs):
        """
        Delete an existing stream.
        Delete an existing stream. The client must have an appropriate delete stream permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.streams_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.streams_id_delete_with_http_info(id, **kwargs)
            return data

    def streams_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing stream.
        Delete an existing stream. The client must have an appropriate delete stream permission.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method streams_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `streams_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/streams/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def streams_id_get(self, id, **kwargs):
        """
        Get details about a stream.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool recursive: Return full details of embedded resources
        :return: Stream
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.streams_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.streams_id_get_with_http_info(id, **kwargs)
            return data

    def streams_id_get_with_http_info(self, id, **kwargs):
        """
        Get details about a stream.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool recursive: Return full details of embedded resources
        :return: Stream
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method streams_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `streams_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/streams/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Stream',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def streams_id_put(self, id, body, **kwargs):
        """
        Create a new or update an existing Stream.
        Create a new Stream. If a stream with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_id_put(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param StreamPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.streams_id_put_with_http_info(id, body, **kwargs)
        else:
            (data) = self.streams_id_put_with_http_info(id, body, **kwargs)
            return data

    def streams_id_put_with_http_info(self, id, body, **kwargs):
        """
        Create a new or update an existing Stream.
        Create a new Stream. If a stream with the posted 'id' already exists then it will be overwritten.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.streams_id_put_with_http_info(id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param StreamPost body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method streams_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `streams_id_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `streams_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/streams/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_get(self, **kwargs):
        """
        Get a collection of users.
        This request will return a collection of all users known to the Sensor Data API. Only Organisation or Admin roles with the read user permission will be authorised.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool expand: Return full details of users
        :param bool recursive: Return full details of roles
        :param str roleids: A commona separated list of roleids to filter the returned roles.
        :return: UserCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_get_with_http_info(**kwargs)
        else:
            (data) = self.users_get_with_http_info(**kwargs)
            return data

    def users_get_with_http_info(self, **kwargs):
        """
        Get a collection of users.
        This request will return a collection of all users known to the Sensor Data API. Only Organisation or Admin roles with the read user permission will be authorised.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool expand: Return full details of users
        :param bool recursive: Return full details of roles
        :param str roleids: A commona separated list of roleids to filter the returned roles.
        :return: UserCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['expand', 'recursive', 'roleids']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))
        if 'roleids' in params:
            query_params.append(('roleids', params['roleids']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/users', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UserCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_userid_get(self, userid, **kwargs):
        """
        Get details about a user.
        Returns a User object for the specified user. You must either be authenticated as the requested user or have an administration or organisation role with read user permission. If a user id is not specified then details about the currently authenticated user will be returned.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_userid_get(userid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str userid: Specify a user id (email address) (required)
        :param bool recursive: Return full details of linked objects
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_userid_get_with_http_info(userid, **kwargs)
        else:
            (data) = self.users_userid_get_with_http_info(userid, **kwargs)
            return data

    def users_userid_get_with_http_info(self, userid, **kwargs):
        """
        Get details about a user.
        Returns a User object for the specified user. You must either be authenticated as the requested user or have an administration or organisation role with read user permission. If a user id is not specified then details about the currently authenticated user will be returned.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_userid_get_with_http_info(userid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str userid: Specify a user id (email address) (required)
        :param bool recursive: Return full details of linked objects
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid', 'recursive']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_userid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params) or (params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `users_userid_get`")


        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/users/{userid}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='User',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_userid_put(self, userid, body, **kwargs):
        """
        Update or create a user.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_userid_put(userid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str userid: Specify a user id (email address) (required)
        :param UserPost body: This must match the userid parameter in the path (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_userid_put_with_http_info(userid, body, **kwargs)
        else:
            (data) = self.users_userid_put_with_http_info(userid, body, **kwargs)
            return data

    def users_userid_put_with_http_info(self, userid, body, **kwargs):
        """
        Update or create a user.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_userid_put_with_http_info(userid, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str userid: Specify a user id (email address) (required)
        :param UserPost body: This must match the userid parameter in the path (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_userid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params) or (params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `users_userid_put`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `users_userid_put`")


        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/users/{userid}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='User',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def vocabulary_get(self, query, type, **kwargs):
        """
        Search for vocabulary terms.
        This operation will query linked registers. A query and type parameter must be provided. Using this operation a client can search for possible matches on both units of measure and observed property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.vocabulary_get(query, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query: Keywords to search. '*' wild cards are permitted. (required)
        :param str type: Uri of concept type. Typically will be http://qudt.org/schema/qudt#Unit for units of measure and http://qudt.org/schema/qudt#QuantityKind for observed properties. Don't forget to URL encode the parameters. (required)
        :return: VocabularyCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.vocabulary_get_with_http_info(query, type, **kwargs)
        else:
            (data) = self.vocabulary_get_with_http_info(query, type, **kwargs)
            return data

    def vocabulary_get_with_http_info(self, query, type, **kwargs):
        """
        Search for vocabulary terms.
        This operation will query linked registers. A query and type parameter must be provided. Using this operation a client can search for possible matches on both units of measure and observed property.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.vocabulary_get_with_http_info(query, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query: Keywords to search. '*' wild cards are permitted. (required)
        :param str type: Uri of concept type. Typically will be http://qudt.org/schema/qudt#Unit for units of measure and http://qudt.org/schema/qudt#QuantityKind for observed properties. Don't forget to URL encode the parameters. (required)
        :return: VocabularyCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query', 'type']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vocabulary_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query' is set
        if ('query' not in params) or (params['query'] is None):
            raise ValueError("Missing the required parameter `query` when calling `vocabulary_get`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `vocabulary_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))
        if 'type' in params:
            query_params.append(('type', params['type']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/vocabulary', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VocabularyCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def vocabulary_proxy_get(self, id, **kwargs):
        """
        Resolve a specific vocabulary term
        This operation will resolve a URI and return a JSON-LD document. Vocabulary terms can be resolved directly, however this operation allows an application to avoid mixed http/https content problems by using https to resolve the term. Only URIs from the whitelisted linked data registry instances are permitted.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.vocabulary_proxy_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: URI of vocabulary term to resolve. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.vocabulary_proxy_get_with_http_info(id, **kwargs)
        else:
            (data) = self.vocabulary_proxy_get_with_http_info(id, **kwargs)
            return data

    def vocabulary_proxy_get_with_http_info(self, id, **kwargs):
        """
        Resolve a specific vocabulary term
        This operation will resolve a URI and return a JSON-LD document. Vocabulary terms can be resolved directly, however this operation allows an application to avoid mixed http/https content problems by using https to resolve the term. Only URIs from the whitelisted linked data registry instances are permitted.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.vocabulary_proxy_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: URI of vocabulary term to resolve. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vocabulary_proxy_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `vocabulary_proxy_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['headerkey', 'kongheader', 'normal', 'querykey']

        return self.api_client.call_api('/vocabularyProxy', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
